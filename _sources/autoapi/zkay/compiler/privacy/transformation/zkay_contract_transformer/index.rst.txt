:mod:`zkay.compiler.privacy.transformation.zkay_contract_transformer`
=====================================================================

.. py:module:: zkay.compiler.privacy.transformation.zkay_contract_transformer

.. autoapi-nested-parse::

   This module provides functionality to transform a zkay AST into an equivalent public solidity AST + proof circuits




Module Contents
---------------

.. function:: transform_ast(ast: AST) -> Tuple[AST, Dict[ConstructorOrFunctionDefinition, CircuitHelper]]

   Convert zkay to solidity AST + proof circuits

   :param ast: zkay AST
   :return: solidity AST and dictionary which maps all function definitions which require verification
            to the corresponding circuit helper instance.


.. py:class:: ZkayTransformer

   Bases: :class:`zkay.zkay_ast.visitor.transformer_visitor.AstTransformerVisitor`

   Transformer which transforms contract level AST elements (contract, function definitions, constructor definitions)

   Contract level transformations:

   * Import public key infrastructure contract and make it available as public constant state variable
   * | Import verification contracts for all functions which require verification and make them available as public constant state variables
     | Note: This transformations initializes those state variables with address 0, which is a placeholder. 0 is replaced with the               real address upon deployment.
   * Transform state variable declarations with owner != @all (replace type by cipher type)
   * For every function and constructor, the parameters and the body are transformed using the transformers defined in zkay_transformer.py

   To support verification, the functions themselves also need additional transformations:

   In the original zkay paper, all the circuit out parameters + the proof are added as additional parameters for all functions which
   require verification.
   This makes it impossible to simply call another function, since every function expects its out arguments + a proof.

   Zkay 2.0 uses an improved design, with the goal of supporting function calls in an elegant way.
   It is based on the following observations:

   1) zk proof verification is only possible in functions which are called externally via a transaction,
      as it requires offchain simulation to generate a valid zero knowledge proof.
   2) public functions can be called externally (transaction) as well as internally (called from other function)
   3) private and internal functions can only be called internally
   4) public functions which have private arguments, but don't contain any private expressions in their body (e.g. because they only
      contain assignments, which are public operations as long as the owner does not change), only need verification if they are called
      externally (since then the parameters are user supplied and thus their encryption needs to be verified)
   5) The difference between an external and an internal function can be reduced to argument encryption verification +
      proof verification via verification contract invocation

   From 1) follows, that the externally called function must also handle the verification of all transitively called functions
   Observations 2), 4) and 5) suggest, that it is sensible to split each public function into two different parts:

    a) An internal function which has the original function body and arguments
    b) An external function which does argument verification, calls the internal function and finally and invokes the verification contract
       (=> "External Wrapper function")

   This way, calling a public function from within another function works exactly the same as calling a private/internal function,
   zkay simply has to reroute the call to the internal function.
   It also means, that no resources are wasted when calling a function such as mentioned in 4) from another function, since in that case
   the internal function does not require verification.

   What's left is how to deal with 1). Zkay 2.0 uses the following solution:

   * | If a function is purely public (no private arguments, no private expressions in itself or any transitively called functions)
     | => No change in signature and no additional transformations
   * If an internal function requires verification (+), 4 additional arguments are added to its signature:

         1) a variable length array where public circuit inputs generated by this function should be stored
         2) a start index which determines at which index this function should start storing circuit inputs into the in array
         3) a variable length array containing public circuit outputs required in this function
         4) a start index which determines where in the uint array the out values for the current function call are located

     * A struct definition is added to the contract definition, which includes entries for every circuit and input variable with correct types.
     * At the beginning of the internal function, a variable of that struct type is declared and all circuit output variables from the out array         parameter are deserialized into the struct.
     * Within the function body, all circuit inputs are stored into the struct and outputs are read from the struct.
     * At the end of the internal function, all circuit input variables in the struct are serialized into the in array parameter.

     When a function calls another function which requires verification, the start indices for in and out array are advanced such that
     they point to the correct sections and the in/out arrays + new start indices are added to the arguments of the call.
     If the called function does not require verification, it is simply called without any additional arguments.

     | (+) An internal function requires verification if it contains private expressions.
     |     *Note*: a function body can contain private variables (!= @all) without containing private expressions,                   since assignment of encrypted variables with the same owner is a public operation.

   * If a function is an external wrapper, 2 additional arguments are added to its signature:

         1) a variable length array containing public circuit outputs for the function itself and all transitively called functions
            If we have a call hierarchy like this::

               func f():
                   calls g(x) which calls h(x)
                   calls h(x)

            then the layout in the output array (same for the input array defined below) will be: f outs | g outs | h outs | h outs
            (i.e. the current functions circuit outputs come first, followed by those of the called functions in the function call order
            (according to AST traversal order))
         2) a zero knowledge proof

     * At the beginning of the external wrapper function a dynamic array is allocated which is large enough to store all circuit inputs
       from all transitively called functions.
     * Next all encrypted arguments are stored in the in array (since the circuit will verify the encryption)
     * Then the wrapper requests all statically known public keys (key for me or for a final address state variable), required by any
       of the transitively called functions, and also stores them in the in array.
     * The corresponding internal function is then called.
       If it requires verification, the newly allocated in array + the out array parameter + initial start indices
       (0 for out array, after last key for in array) are added as additional arguments.
     * Finally the verification contract is invoked to verify the proof (the in array was populated by the called functions themselves).

   .. attribute:: circuits
      :annotation: :Dict[ConstructorOrFunctionDefinition, CircuitHelper]

      Abstract circuits for all functions which require verification


   .. attribute:: var_decl_trafo
      

      Transformer for state variable declarations and parameters


   .. method:: import_contract(cname: str, su: SourceUnit, corresponding_circuit: Optional[CircuitHelper] = None)
      :staticmethod:


      Import contract 'vname' into the given source unit.

      :param cname: contract name (.sol filename stem must match contract type name)
      :param su: [SIDE EFFECT] source unit where contract should be imported
      :param corresponding_circuit: [SIDE EFFECT] if contract is a verification contract, this should be the corresponding circuit helper


   .. method:: create_contract_variable(cname: str)
      :staticmethod:


      Create a public constant state variable with which contract with name 'cname' can be accessed


   .. method:: include_verification_contracts(self, su: SourceUnit, c: ContractDefinition)


      Import all verification contracts for 'c' into 'su' and create state variable declarations for all of them + the pki contract.

      :param su: [SIDE EFFECT] source unit into which contracts should be imported
      :param c: contract for which verification contracts should be imported
      :return: list of all constant state variable declarations for the pki contract + all the verification contracts


   .. method:: create_circuit_helper(fct: ConstructorOrFunctionDefinition, global_owners: List[PrivacyLabelExpr], internal_circ: Optional[CircuitHelper] = None)
      :staticmethod:


      Create circuit helper for the given function.

      :param fct: function for which to create a circuit
      :param global_owners: list of all statically known privacy labels (me + final address state variables)
      :param internal_circ: the circuit of the internal function on which to base this circuit
                            (only used when creating the circuit of the external wrapper function)
      :return: new circuit helper


   .. method:: visitSourceUnit(self, ast: SourceUnit)



   .. method:: transform_contract(self, su: SourceUnit, c: ContractDefinition)


      Transform an entire zkay contract into a public solidity contract.

      This:

      * transforms state variables, function bodies and signatures
      * import verification contracts
      * adds zk_data structs for each function with verification           (to store circuit I/O, to bypass solidity stack limit and allow for easy assignment of array variables),
      * creates external wrapper functions for all public functions which require verification
      * adds circuit IO serialization/deserialization code from/to zk_data struct to all functions which require verification.

      :param su: [SIDE EFFECTS] Source unit of which this contract is part of
      :param c: [SIDE EFFECTS] The contract to transform
      :return: The contract itself


   .. method:: create_internal_verification_wrapper(self, ast: ConstructorOrFunctionDefinition)


      Add the necessary additional parameters and boiler plate code for verification support to the given function.

      :param ast: [SIDE EFFECT] Internal function which requires verification


   .. method:: split_into_external_and_internal_fct(self, f: ConstructorOrFunctionDefinition, original_params: List[Parameter], global_owners: List[PrivacyLabelExpr])


      Take public function f and split it into an internal function and an external wrapper function.

      :param f: [SIDE EFFECT] function to split (at least requires_verification_if_external)
      :param original_params: list of transformed function parameters without additional parameters added due to transformation
      :param global_owners: list of static labels (me + final address state variable identifiers)
      :return: Tuple of newly created external and internal function definitions


   .. method:: create_external_wrapper_body(int_fct: ConstructorOrFunctionDefinition, ext_circuit: CircuitHelper, original_params: List[Parameter], requires_proof: bool)
      :staticmethod:


      Return Block with external wrapper function body.

      :param int_fct: corresponding internal function
      :param ext_circuit: [SIDE EFFECT] circuit helper of the external wrapper function
      :param original_params: list of transformed function parameters without additional parameters added due to transformation
      :return: body with wrapper code



